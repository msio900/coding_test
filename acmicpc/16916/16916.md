# 16916 : 부분 문자열 [↩](../../acmicpc)

[16916 : 부분 문자열](https://www.acmicpc.net/problem/16916)

| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
| 1 초      | 512 MB      | 12114 | 3870 | 2840      | 37.221%   |

## 문제

문자열 S의 부분 문자열이란, 문자열의 연속된 일부를 의미한다.

예를 들어, "aek", "joo", "ekj"는 "baekjoon"의 부분 문자열이고, "bak", "p", "oone"는 부분 문자열이 아니다.

문자열 S와 P가 주어졌을 때, P가 S의 부분 문자열인지 아닌지 알아보자.

## 입력

첫째 줄에 문자열 S, 둘째 줄에 문자열 P가 주어진다. 두 문자열은 빈 문자열이 아니며, 길이는 100만을 넘지 않는다. 또, 알파벳 소문자로만 이루어져 있다.

## 출력

P가 S의 부분 문자열이면 1, 아니면 0을 출력한다.

### 예제 입력

```python
in[0]
baekjoon
aek

out[0]
1

in[1]
baekjoon
bak

out[1]
0

in[2]
baekjoon
joo

out[2]
1

in[3]
baekjoon
oone

out[3]
0

in[4]
baekjoon
online

out[4]
0

in[5]
baekjoon
baekjoon

out[5]
1
```

---

## 💡풀이

### 1차 시도

```python
import sys
import heapq

input = sys.stdin.readline

INF = sys.maxsize

V, E = map(int, input().split())
K = int(input())
min_d = [INF] * (V+1)
graph = [[] for _ in range(V + 1)]
heap = []

for _ in range(E):
    u, v, w = map(int, input().split())
    graph[u].append((w, v))

min_d[K] = 0
heapq.heappush(heap, (0, K))
while heap:
    distance, node = heapq.heappop(heap)

    if min_d[node] < distance:
        continue
    for dis, nxt_node in graph[node]:
        nxt_dis = dis + distance
        if nxt_dis < min_d[nxt_node]:
            min_d[nxt_node] = nxt_dis
            heapq.heappush(heap, (nxt_dis, nxt_node))


for i in range(1, V+1):
    print("INF" if min_d[i] == INF else min_d[i])
```

### 성공😊

![image-20221227215328159](images/image-20221227215328159.png)

* 다익스트라 알고리즘을 구현하여 풀이
* heap 자료구조의 선행 공부 필요함