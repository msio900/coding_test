# 1406ë²ˆ : ì—ë””í„° [â†©](../../acmicpc)

[1406ë²ˆ : ì—ë””í„°](https://www.acmicpc.net/problem/1406)

## ğŸ–‹ï¸ë¬¸ì œ

í•œ ì¤„ë¡œ ëœ ê°„ë‹¨í•œ ì—ë””í„°ë¥¼ êµ¬í˜„í•˜ë ¤ê³  í•œë‹¤. ì´ í¸ì§‘ê¸°ëŠ” ì˜ì–´ ì†Œë¬¸ìë§Œì„ ê¸°ë¡í•  ìˆ˜ ìˆëŠ” í¸ì§‘ê¸°ë¡œ, ìµœëŒ€ 600,000ê¸€ìê¹Œì§€ ì…ë ¥í•  ìˆ˜ ìˆë‹¤.

ì´ í¸ì§‘ê¸°ì—ëŠ” 'ì»¤ì„œ'ë¼ëŠ” ê²ƒì´ ìˆëŠ”ë°, ì»¤ì„œëŠ” ë¬¸ì¥ì˜ ë§¨ ì•(ì²« ë²ˆì§¸ ë¬¸ìì˜ ì™¼ìª½), ë¬¸ì¥ì˜ ë§¨ ë’¤(ë§ˆì§€ë§‰ ë¬¸ìì˜ ì˜¤ë¥¸ìª½), ë˜ëŠ” ë¬¸ì¥ ì¤‘ê°„ ì„ì˜ì˜ ê³³(ëª¨ë“  ì—°ì†ëœ ë‘ ë¬¸ì ì‚¬ì´)ì— ìœ„ì¹˜í•  ìˆ˜ ìˆë‹¤. ì¦‰ ê¸¸ì´ê°€ Lì¸ ë¬¸ìì—´ì´ í˜„ì¬ í¸ì§‘ê¸°ì— ì…ë ¥ë˜ì–´ ìˆìœ¼ë©´, ì»¤ì„œê°€ ìœ„ì¹˜í•  ìˆ˜ ìˆëŠ” ê³³ì€ L+1ê°€ì§€ ê²½ìš°ê°€ ìˆë‹¤.

ì´ í¸ì§‘ê¸°ê°€ ì§€ì›í•˜ëŠ” ëª…ë ¹ì–´ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

| L    | ì»¤ì„œë¥¼ ì™¼ìª½ìœ¼ë¡œ í•œ ì¹¸ ì˜®ê¹€ (ì»¤ì„œê°€ ë¬¸ì¥ì˜ ë§¨ ì•ì´ë©´ ë¬´ì‹œë¨)  |
| :--- | ------------------------------------------------------------ |
| D    | ì»¤ì„œë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ ì˜®ê¹€ (ì»¤ì„œê°€ ë¬¸ì¥ì˜ ë§¨ ë’¤ì´ë©´ ë¬´ì‹œë¨) |
| B    | ì»¤ì„œ ì™¼ìª½ì— ìˆëŠ” ë¬¸ìë¥¼ ì‚­ì œí•¨ (ì»¤ì„œê°€ ë¬¸ì¥ì˜ ë§¨ ì•ì´ë©´ ë¬´ì‹œë¨) ì‚­ì œë¡œ ì¸í•´ ì»¤ì„œëŠ” í•œ ì¹¸ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•œ ê²ƒì²˜ëŸ¼ ë‚˜íƒ€ë‚˜ì§€ë§Œ, ì‹¤ì œë¡œ ì»¤ì„œì˜ ì˜¤ë¥¸ìª½ì— ìˆë˜ ë¬¸ìëŠ” ê·¸ëŒ€ë¡œì„ |
| P $  | $ë¼ëŠ” ë¬¸ìë¥¼ ì»¤ì„œ ì™¼ìª½ì— ì¶”ê°€í•¨                              |

ì´ˆê¸°ì— í¸ì§‘ê¸°ì— ì…ë ¥ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ì´ ì£¼ì–´ì§€ê³ , ê·¸ ì´í›„ ì…ë ¥í•œ ëª…ë ¹ì–´ê°€ ì°¨ë¡€ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•˜ê³  ë‚œ í›„ í¸ì§‘ê¸°ì— ì…ë ¥ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤. ë‹¨, ëª…ë ¹ì–´ê°€ ìˆ˜í–‰ë˜ê¸° ì „ì— ì»¤ì„œëŠ” ë¬¸ì¥ì˜ ë§¨ ë’¤ì— ìœ„ì¹˜í•˜ê³  ìˆë‹¤ê³  í•œë‹¤.

### ì…ë ¥

ì²«ì§¸ ì¤„ì—ëŠ” ì´ˆê¸°ì— í¸ì§‘ê¸°ì— ì…ë ¥ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ì´ ì£¼ì–´ì§„ë‹¤. ì´ ë¬¸ìì—´ì€ ê¸¸ì´ê°€ Nì´ê³ , ì˜ì–´ ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ê¸¸ì´ëŠ” 100,000ì„ ë„˜ì§€ ì•ŠëŠ”ë‹¤. ë‘˜ì§¸ ì¤„ì—ëŠ” ì…ë ¥í•  ëª…ë ¹ì–´ì˜ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ M(1 â‰¤ M â‰¤ 500,000)ì´ ì£¼ì–´ì§„ë‹¤. ì…‹ì§¸ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ ì…ë ¥í•  ëª…ë ¹ì–´ê°€ ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§„ë‹¤. ëª…ë ¹ì–´ëŠ” ìœ„ì˜ ë„¤ ê°€ì§€ ì¤‘ í•˜ë‚˜ì˜ í˜•íƒœë¡œë§Œ ì£¼ì–´ì§„ë‹¤.


### ì¶œë ¥

ì²«ì§¸ ì¤„ì— ëª¨ë“  ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•˜ê³  ë‚œ í›„ í¸ì§‘ê¸°ì— ì…ë ¥ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ì„ ì¶œë ¥í•œë‹¤. 

### ì˜ˆì œ ì…ë ¥

```python
in[0]
abcd
3
P x
L
P y

out[0]
abcdyx

in[1]
abc
9
L
L
L
L
L
P x
L
B
P y

out[1]
yxabc

in[2]
dmih
11
B
B
P x
L
B
B
B
P y
D
D
P z

out[2]
yxz

```

---

## ğŸ’¡í’€ì´

* 1ì°¨ì‹œ

```python
import sys

N_list = list(sys.stdin.readline().strip())

M = int(sys.stdin.readline())
cursor = len(N_list)

for _ in range(M):
    move = sys.stdin.readline().split()
    if move[0] == 'L':
        if cursor > 0:
            cursor -= 1

        else:
            pass

    if move[0] == 'D':
        if cursor < len(N_list):
            cursor += 1
        else:
            pass

    if move[0] == 'B':
        if cursor <= 0:
            pass
        else:
            del N_list[cursor-1]
            cursor -= 1

    if move[0] == 'P':
        N_list.insert(cursor, move[1])
        cursor += 1


print(N_list)

```


### ì‹¤íŒ¨ğŸ˜‚

* ì‹œê°„ ì´ˆê³¼

## âœï¸í’€ì´ ì •ë¦¬

> ì •ë¦¬ ì½”ë“œ [âŒ¨ï¸](../../baaarking_dog_algorithm_lecture/0x03_10808.py)

- ë³¸ ë¬¸ì œëŠ” `ì—°ê²° ë¦¬ìŠ¤íŠ¸` ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ í˜¹ì€ `ìŠ¤íƒ` ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ í’€ ìˆ˜ ìˆìŒ.
  - íŒŒì´ì¬ì€ `ì—°ê²° ë¦¬ìŠ¤íŠ¸` ìë£Œêµ¬ì¡°ë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì •ì‹ìœ¼ë¡œëŠ” í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•´ì•¼ í•¨.
  - í•˜ì§€ë§Œ ì´ë¥¸ë°” ì•¼ë§¤ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ í†µí•´ì„œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ
- í•˜ì§€ë§Œ ì„±ëŠ¥ì€ `stack`ì„ í™œìš©í•œ ìë£Œêµ¬ì¡°ê°€ ê°€ì¥ ì„±ëŠ¥ì´ ì¢‹ìŒ.

### ê°„í¸í•œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•œ í’€ì´

> ë°”í‚¹ë…ë‹˜ ë°©ì‹

```python
import sys

input = sys.stdin.readline

s = input().rstrip()
n = int(input())

# ê°„í¸í•œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬í˜„
mx =1000005
dat = [-1]*mx
pre = [-1]*mx
nxt = [-1]*mx

unused = 1

# ì—°ê²° ë¦¬ìŠ¤íŠ¸ì— ì›ì†Œ ì‚½ì…
def insert(addr:int, num:int):
    global unused
    dat[unused] = num
    pre[unused] = addr
    nxt[unused] = nxt[addr]
    if nxt[addr] != -1:
        pre[nxt[addr]] = unused
    nxt[addr] = unused
    unused += 1

# ì—°ê²° ë¦¬ìŠ¤íŠ¸ì— íŠ¹ì • ì£¼ì†Œ ì›ì†Œ ì œê±°
def erase(addr:int):
    nxt[pre[addr]] = nxt[addr]
    if nxt[addr] != -1:
        pre[nxt[addr]] = pre[addr]

# ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ ì¶œë ¥
def traverse():
    cur = nxt[0]
    while cur != -1:
        print(dat[cur], end='')
        cur = nxt[cur]

cursor = 0 # ì»¤ì„œ ê·œì •

# ì…ë ¥ë°›ì€ ë¬¸ìì—´ S ì›ì†Œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
for i in s:
    insert(cursor, i)
    cursor +=1

for _ in range(n):
    command = input().split()
    if command[0] == 'L': # 
        if pre[cursor] != -1:
            cursor = pre[cursor]
    elif command[0] == 'D':
        if nxt[cursor] != -1:
            cursor = nxt[cursor]
    elif command[0] == 'B':
        if pre[cursor] != -1:
            erase(cursor)
            cursor = pre[cursor]
    else:
        insert(cursor, command[1])
        cursor = nxt[cursor]
traverse()
```

### ì •ì‹ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•œ í’€ì´

> ìˆ˜ë¯¼ë‹˜ í’€ì´ ì°¸ê³ 

```python
import sys

class Node:
    def __init__(self, item):
        self.data = item
        self.prev = None
        self.next = None


class DoublyLinkedList:
    def __init__(self):
        self.nodeCount = 0
        self.head = Node(None)
        self.tail = Node(None)
        self.head.prev = None
        self.head.next = self.tail
        self.tail.prev = self.head
        self.tail.next = None
        self.cursor = self.tail

    # ë¦¬ìŠ¤íŠ¸ ìˆœíšŒ
    def traverse(self):
        result = []
        curr = self.head
        while curr.next.next:
            curr = curr.next
            result.append(curr.data)
        return result

    # íŠ¹ì • ì›ì†Œ ì°¸ì¡°
    def getAt(self, pos):  # getAt(0) -> head
        if pos < 0 or pos > self.nodeCount:
            return None

        if pos > self.nodeCount // 2:
            i = 0
            curr = self.tail
            while i < self.nodeCount - pos + 1:
                curr = curr.prev
                i += 1
        else:
            i = 0
            curr = self.head
            while i < pos:
                curr = curr.next
                i += 1
        return curr

    # ì›ì†Œì˜ ì‚½ì…
    def insertAfter(self, prev, newNode):  # prevê°€ ê°€ë¦¬í‚¤ëŠ” nodeì˜ ë‹¤ìŒì— newNodeë¥¼ ì‚½ì…í•˜ê³  ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ True/Falseë¥¼ ë¦¬í„´
        next = prev.next
        newNode.prev = prev
        newNode.next = next
        prev.next = newNode
        next.prev = newNode
        self.nodeCount += 1
        return True

    def insertBefore(self, next, newNode):
        prev = next.prev
        newNode.prev = prev
        newNode.next = next
        prev.next = newNode
        next.prev = newNode
        self.nodeCount += 1
        return True

    def insertAt(self, pos, newNode):
        if pos < 1 or pos > self.nodeCount + 1:
            return False
        prev = self.getAt(pos - 1)  # newNodeê°€ ì‚½ì…ë  ìœ„ì¹˜
        return self.insertAfter(prev, newNode)

    def popBefore(self, next):  # nextì˜ ì´ì „ì— ìˆë˜ nodeë¥¼ ì‚­ì œí•˜ê³ , ê·¸ nodeì˜ dataë¥¼ ë¦¬í„´
        curr = next.prev
        prev = curr.prev
        prev.next = next
        next.prev = prev
        self.nodeCount -= 1
        return curr.data

input = sys.stdin.readline

s = input().rstrip()
n = int(input())
linked_list = DoublyLinkedList()

for i in range(len(s)):
    linked_list.insertAt(i+1, Node(s[i]))

for _ in range(n):
    command = input().split()
    if command[0] == 'L':
        if linked_list.cursor.prev.prev:
            linked_list.cursor = linked_list.cursor.prev
    elif command[0] == 'D':
        if linked_list.cursor.next:
            linked_list.cursor = linked_list.cursor.next
    elif command[0] == 'B':
        if linked_list.cursor.prev.prev:
            linked_list.popBefore(linked_list.cursor)
    else:
        node = Node(command[1])
        linked_list.insertBefore(linked_list.cursor, node)

print(''.join(linked_list.traverse()))
```

### ìŠ¤íƒì„ ì´ìš©í•œ í’€ì´

```python
import sys

input = sys.stdin.readline

L_stack = list(map(str, input().rstrip()))

M = int(input())

R_stack = []
# ì»¤ì„œì˜ ìœ„ì¹˜ëŠ” ëª…ë ¹ì–´ê°€ ìˆ˜í–‰ë˜ê¸° ì „ì—ëŠ” ë§¨ ë’¤ì— ìœ„ì¹˜í•˜ê³  ìˆìŒ.
for _ in range(M):
    command = input().split()
    if command[0] == 'L' and L_stack :
        R_stack.append(L_stack.pop())

    if command[0] == 'D' and R_stack:
        L_stack.append(R_stack.pop())

    if command[0] == 'B'and L_stack:
        L_stack.pop()

    if command[0] == 'P':
        L_stack.append(command[1])

R_stack.reverse()
print(''.join(L_stack+R_stack))
```

### ê²°ê³¼

|                         | ë©”ëª¨ë¦¬   | ì‹œê°„   | ì½”ë“œ ê¸¸ì´ |
| ----------------------- | -------- | ------ | --------- |
| ê°„í¸í•œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ í™œìš© | 75788KB  | 920ms  | 1078B     |
| ì •ì‹ ì—°ê²° ë¦¬ìŠ¤íŠ¸ í™œìš©   | 131808KB | 1688ms | 2940B     |
| ìŠ¤íƒ í™œìš©               | 40676KB  | 384ms  | 580B      |

 
